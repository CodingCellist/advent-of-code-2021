import System
import System.File.Virtual
import System.File.ReadWrite

import Data.Maybe
import Data.String

-- https://github.com/idris-lang/Idris2/pull/2163/commits/49035a8066e77b17cd3601724430bc98086ef6bc
die : HasIO io => String -> io a
die str = do putStrLn str; exitFailure

-- let's try it this way, just for fun...

data DepSub : (d, hPos : Nat) -> Type where
   MkDepSub : (d, hPos : Nat) -> DepSub d hPos

-- okay, the fact that these can be generated by Idris from the type info, is
-- pretty cool! (I have made some minor changes to improve things, but left in
-- the auto-generated versions for comparison)

up      : (n : Nat) -> DepSub d hPos -> DepSub (d `minus` n) hPos
up n (MkDepSub d _) = MkDepSub (minus d n) hPos
-- up 0 x = let MkDepSub d hPos = x in MkDepSub (minus d 0) hPos
-- up (S k) (MkDepSub _ _) = MkDepSub (minus d (S k)) hPos

down    : (n : Nat) -> DepSub d hPos -> DepSub (d + n) hPos
down n (MkDepSub d _) = MkDepSub (plus d n) hPos
-- down 0 x = let MkDepSub d hPos = x in MkDepSub (plus d 0) hPos
-- down (S k) (MkDepSub _ _) = MkDepSub (plus d (S k)) hPos

forward : (n : Nat) -> DepSub d hPos -> DepSub d (hPos + n)
forward n (MkDepSub _ hPos) = MkDepSub d (plus hPos n)
-- forward 0 x = let MkDepSub d hPos = x in MkDepSub d (plus hPos 0)
-- forward (S k) (MkDepSub _ _) = MkDepSub d (plus hPos (S k))

--- data TString : String -> Type where
---   TheString : (s : String) -> TString s
--- 
--- liftString : (s : String) -> TString s
--- liftString s = TheString s

data CmdString : String -> Nat -> Type where
  Up : String -> (n : Nat) -> CmdString "up" n
  Down : String -> (n : Nat) -> CmdString "down" n
  Forward : String -> (n : Nat) -> CmdString "forward" n

toCmd : (s : String) -> (n : Nat) -> Maybe (CmdString s n)
toCmd s@"up" n = Just (Up s n)
toCmd s@"down" n = Just (Down s n)
toCmd s@"forward" n = Just (Forward s n)
toCmd _ _ = Nothing

cmdResType : CmdString s n -> DepSub d hPos -> Type
cmdResType (Up _ n) (MkDepSub d hPos) = DepSub (d `minus` n) hPos
cmdResType (Down _ n) (MkDepSub d hPos) = DepSub (d + n) hPos
cmdResType (Forward _ n) (MkDepSub d hPos) = DepSub d (hPos + n)

-- this function is freaking auto-generated!
runCmd : (cmd : CmdString s n) -> (ds : DepSub d hPos) -> cmdResType cmd ds
runCmd (Up x _) (MkDepSub _ _) = MkDepSub (minus d n) hPos
runCmd (Down x _) (MkDepSub _ _) = MkDepSub (plus d n) hPos
runCmd (Forward x _) (MkDepSub _ _) = MkDepSub d (plus hPos n)

(>>=) :  (ds : DepSub d hPos)
      -> (doThis : DepSub d hPos -> DepSub d' hPos')
      -> DepSub d' hPos'
(>>=) ds doThis = doThis ds

step : (s : String) -> (n : Nat) -> (ds : DepSub d hPos)
     -> (case toCmd s n of
              Just cmd => cmdResType cmd ds
              Nothing  => Unit)
step s n ds with (toCmd s n)
  step s n ds | Nothing = ()
  step s n ds | (Just cmd) = runCmd cmd ds

loop : HasIO io => (ds : DepSub d h) -> io ?thing
loop ds =
  do Right l <- fGetLine stdin
       | Left err => die $ show err 
     (s :: rn :: []) <- pure $ words l
       | _ => die "Expected 2 words"
     (Just n) <- pure $ parsePositive rn
       | Nothing => die "2nd arg was not positive."
     let ds' = step s n ds
     -- pure ds'
     ?iGiveUp

main : IO ()
main =
  do Right l <- fGetLine stdin
       | Left err => die $ show err 
     (s :: rn :: []) <- pure $ words l
       | _ => die "Expected 2 words"
     (Just n) <- pure $ parsePositive rn
       | Nothing => die "2nd arg was not positive."
     ?main_rhs

